package com.example.hikingapp.ui.ar

import android.Manifest
import android.content.pm.PackageManager
import android.hardware.SensorManager
import android.location.Location
import android.os.Bundle
import android.util.Log
import android.webkit.*
import androidx.appcompat.app.AppCompatActivity
import androidx.core.app.ActivityCompat
import androidx.core.content.getSystemService
import com.example.hikingapp.R
import com.google.ar.sceneform.AnchorNode
import com.mapbox.android.core.location.LocationEngineProvider
import com.mapbox.geojson.Point
import com.mapbox.mapboxsdk.Mapbox
import com.mapbox.mapboxsdk.location.LocationComponentActivationOptions
import com.mapbox.mapboxsdk.maps.MapboxMap
import com.mapbox.mapboxsdk.maps.SupportMapFragment
import com.mapbox.maps.Style
import com.mapbox.navigation.core.trip.session.LocationMatcherResult
import com.mapbox.navigation.core.trip.session.LocationObserver
import com.mapbox.navigation.ui.maps.camera.NavigationCamera
import com.mapbox.navigation.ui.maps.camera.data.MapboxNavigationViewportDataSource
import com.mapbox.navigation.ui.maps.camera.transition.NavigationCameraTransitionOptions
import com.mapbox.navigation.ui.maps.location.NavigationLocationProvider
import com.mapbox.search.*
import com.mapbox.search.result.SearchResult

class ArActivity : AppCompatActivity() {


    // MAPBOX CODE

    //    private lateinit var searchEngine: SearchEngine
    private lateinit var reverseGeocodingEngine: ReverseGeocodingSearchEngine
    private lateinit var anchorNode: AnchorNode
    private lateinit var navigationCamera: NavigationCamera

    private lateinit var arFragment: CustomArFragment
    private lateinit var mapFragment: SupportMapFragment

    private lateinit var searchRequestTask: SearchRequestTask

    private lateinit var map: MapboxMap

    private val accelerometerReading = FloatArray(3)
    private val magnetometerReading = FloatArray(3)
    private val rotationMatrix = FloatArray(9)
    private val orientationAngles = FloatArray(3)

    private var places = mutableListOf<Place>()


    /**
     * Produces the camera frames based on the location and routing data for the [navigationCamera] to execute.
     */
    private lateinit var viewportDataSource: MapboxNavigationViewportDataSource

    /**
     * [NavigationLocationProvider] is a utility class that helps to provide location updates generated by the Navigation SDK
     * to the Maps SDK in order to update the user location indicator on the map.
     */
    private val navigationLocationProvider = NavigationLocationProvider()

    /**
     * Gets notified with location updates.
     *
     * Exposes raw updates coming directly from the location services
     * and the updates enhanced by the Navigation SDK (cleaned up and matched to the road).
     */
    private val locationObserver = object : LocationObserver {
        var firstLocationUpdateReceived = false

        override fun onNewRawLocation(rawLocation: Location) {
            // not handled
        }

        override fun onNewLocationMatcherResult(locationMatcherResult: LocationMatcherResult) {
            val enhancedLocation = locationMatcherResult.enhancedLocation
            // update location puck's position on the map
            navigationLocationProvider.changePosition(
                location = enhancedLocation,
                keyPoints = locationMatcherResult.keyPoints,
            )

            // update camera position to account for new location
            viewportDataSource.onLocationChanged(enhancedLocation)
            viewportDataSource.evaluate()

            // if this is the first location update the activity has received,
            // it's best to immediately move the camera to the current user location
            if (!firstLocationUpdateReceived) {
                firstLocationUpdateReceived = true
                navigationCamera.requestNavigationCameraToOverview(
                    stateTransitionOptions = NavigationCameraTransitionOptions.Builder()
                        .maxDuration(0) // instant transition
                        .build()
                )
            }
        }
    }

    private val searchCallback: SearchCallback = object : SearchCallback {

        override fun onError(e: Exception) {
            Log.i("SearchApiExample", "Reverse geocoding error", e)
        }

        override fun onResults(results: List<SearchResult>, responseInfo: ResponseInfo) {
            if (results.isEmpty()) {
                Log.i("SearchApiExample", "No reverse geocoding results")
            } else {
                Log.i("SearchApiExample", "Reverse geocoding results: $results")

                results.forEach {
                    val place = Place(it.id, "marker", it.name, it.coordinate!!)
                    places.add(place)
                }
            }
        }
    }


    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        Mapbox.getInstance(this, getString(R.string.mapbox_access_token))

        setContentView(R.layout.activity_ar)

        arFragment = supportFragmentManager.findFragmentById(R.id.ar_fragment) as CustomArFragment
        mapFragment =
            supportFragmentManager.findFragmentById(R.id.map_fragment) as SupportMapFragment

        val sensorManager: SensorManager = getSystemService()!!

        MapboxSearchSdk.initialize(
            application = this.application,
            accessToken = getString(R.string.mapbox_access_token),
            locationEngine = LocationEngineProvider.getBestLocationEngine(this)
        )

//        searchEngine = MapboxSearchSdk.getSearchEngine()
        reverseGeocodingEngine = MapboxSearchSdk.getReverseGeocodingSearchEngine()

        /*placesService = PlacesService.create()
        fusedLocationClient = LocationServices.getFusedLocationProviderClient(this)*/

        /* navigationCamera = NavigationCamera(
             mapboxMap,
             binding.mapView.camera,
             viewportDataSource
         )*/
        setUpAr()
        setUpMaps()

    }

    private fun setUpMaps() {
        mapFragment.getMapAsync {

            if (ActivityCompat.checkSelfPermission(
                    this,
                    Manifest.permission.ACCESS_FINE_LOCATION
                ) != PackageManager.PERMISSION_GRANTED && ActivityCompat.checkSelfPermission(
                    this,
                    Manifest.permission.ACCESS_COARSE_LOCATION
                ) != PackageManager.PERMISSION_GRANTED
            ) {
                // TODO: Consider calling
                //    ActivityCompat#requestPermissions
                // here to request the missing permissions, and then overriding
                //   public void onRequestPermissionsResult(int requestCode, String[] permissions,
                //                                          int[] grantResults)
                // to handle the case where the user grants the permission. See the documentation
                // for ActivityCompat#requestPermissions for more details.
                return@getMapAsync
            }


            map = it
            map.setStyle(Style.MAPBOX_STREETS) {
                val locationComponentOptions = LocationComponentActivationOptions
                    .builder(this, it)
                    .useDefaultLocationEngine(true)
                    .build()

                map.locationComponent.activateLocationComponent(locationComponentOptions)
                map.locationComponent.isLocationComponentEnabled = true

                val reverseOptions =
                    ReverseGeoOptions(Point.fromLngLat(23.771381150489923, 38.00469530315156))


                reverseGeocodingEngine.search(reverseOptions, searchCallback)
            }
        }
    }

    private fun setUpAr() {
        arFragment.setOnTapArPlaneListener { hitResult, _, _ ->
            // TODO Create anchor here
            val anchor = hitResult.createAnchor()
            anchorNode = AnchorNode(anchor)
            anchorNode?.setParent(arFragment.arSceneView.scene)
            addPlaces(anchorNode!!)
        }
    }

    private fun addPlaces(anchorNode: AnchorNode) {


//        val currentLocation = currentLocation
        val currentLocation = map.locationComponent.lastKnownLocation
        if (currentLocation == null) {
            Log.w("Method - addPlaces: ", "Location has not been determined yet")
            return
        }

        val places = places
        if (places == null) {
            Log.w("Method - addPlaces: ", "No places to put")
            return
        }

        for (place in places) {
            // Add the place in AR
            // TODO set localPosition
            val placeNode = PlaceNode(this, place)
            placeNode.setParent(anchorNode)
            placeNode.localPosition = place.getPositionVector(orientationAngles[0], Point.fromLngLat(currentLocation.longitude,currentLocation.latitude))

            placeNode.setOnTapListener { _, _ ->
                showInfoWindow(place)
            }

            // Add the place in maps
           /* map?.let {
                val marker = it.addMarker(
                    MarkerOptions()
                        .position(place.geometry.location.latLng)
                        .title(place.name)
                )
                marker.tag = place
                markers.add(marker)
            }*/
        }

//        val reverseOptions = ReverseGeoOptions.Builder(Point.fromLngLat(map.locationComponent.lastKnownLocation!!.longitude,map.locationComponent.lastKnownLocation!!.latitude)).limit(10).build()


        /*println("Made a geocoding API call")
        searchEngine.search(
            newText,
            SearchOptions.Builder().limit(10).build(), searchCallback
        )*/


        /*map.locationComponent.lastKnownLocation.
        val placeNode = PlaceNode(this, place)
        placeNode.setParent(anchorNode)
        placeNode.localPosition = place.getPositionVector(orientationAngles[0], currentLocation.latLng)

        placeNode.setOnTapListener { _, _ ->
            showInfoWindow(place)
        }*/

    }

    private fun showInfoWindow(place: Place) {
        // Show in AR
        val matchingPlaceNode = anchorNode?.children?.filter {
            it is PlaceNode
        }?.first {
            val otherPlace = (it as PlaceNode).place ?: return@first false
            return@first otherPlace == place
        } as? PlaceNode
        matchingPlaceNode?.showInfoWindow()

        // Show as marker
       /* val matchingMarker = markers.firstOrNull {
            val placeTag = (it.tag as? Place) ?: return@firstOrNull false
            return@firstOrNull placeTag == place
        }
        matchingMarker?.showInfoWindow()*/
    }

}


/*  WEBVIEW IMPLEMENTATION

val webView = WebView(this)
setContentView(webView)

setUpWebViewDefaults(webView);

webView.loadUrl("https://chriszo.github.io/ar-js-test6y7i5l/")
webView.webChromeClient = object : WebChromeClient() {

    override fun onGeolocationPermissionsShowPrompt(
        origin: String?,
        callback: GeolocationPermissions.Callback
    ) {
        callback.invoke(origin, true, false)
    }


    override fun onPermissionRequest(request: PermissionRequest) {
//                request.grant(request.getResources())


        Log.d(TAG, "onPermissionRequest")
        val requestedResources: Array<String>
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
            requestedResources = request.resources
            for (r in requestedResources) {
                if (r == PermissionRequest.RESOURCE_VIDEO_CAPTURE) {
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                        request.grant(arrayOf(PermissionRequest.RESOURCE_VIDEO_CAPTURE))
                    }
                    break
                }
            }
        }
    }
}
}


private fun setUpWebViewDefaults(webView: WebView) {

val settings: WebSettings = webView.settings

// Enable Javascript

// Enable Javascript
settings.javaScriptEnabled = true
// Use WideViewport and Zoom out if there is no viewport defined

// Use WideViewport and Zoom out if there is no viewport defined
settings.useWideViewPort = true
settings.loadWithOverviewMode = true

// Enable pinch to zoom without the zoom buttons

// Enable pinch to zoom without the zoom buttons
settings.builtInZoomControls = true

// Allow use of Local Storage

// Allow use of Local Storage
settings.domStorageEnabled = true

if (Build.VERSION.SDK_INT > Build.VERSION_CODES.HONEYCOMB) {
    // Hide the zoom controls for HONEYCOMB+
    settings.displayZoomControls = true
}

// Enable remote debugging via chrome://inspect

// Enable remote debugging via chrome://inspect
if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
    WebView.setWebContentsDebuggingEnabled(true)
}

webView.webViewClient = WebViewClient()

// AppRTC requires third party cookies to work

// AppRTC requires third party cookies to work
val cookieManager: CookieManager = CookieManager.getInstance()
cookieManager.setAcceptThirdPartyCookies(webView, true)

}

inner class MyRendererTrackingWebViewClient : WebViewClient() {
private var mWebView: WebView? = null

@RequiresApi(Build.VERSION_CODES.O)
override fun onRenderProcessGone(view: WebView, detail: RenderProcessGoneDetail): Boolean {
    if (!detail.didCrash()) {
        // Renderer was killed because the system ran out of memory.
        // The app can recover gracefully by creating a new WebView instance
        // in the foreground.
        Log.e("MY_APP_TAG", ("System killed the WebView rendering process " +
                "to reclaim memory. Recreating..."))

        mWebView?.also { webView ->
            val webViewContainer: ViewGroup = findViewById(R.id.ar_webview)
            webViewContainer.removeView(webView)
            webView.destroy()
            mWebView = null
        }

        // By this point, the instance variable "mWebView" is guaranteed
        // to be null, so it's safe to reinitialize it.

        return true // The app continues executing.
    }

    // Renderer crashed because of an internal error, such as a memory
    // access violation.
    Log.e("MY_APP_TAG", "The WebView rendering process crashed!")

    // In this example, the app itself crashes after detecting that the
    // renderer crashed. If you choose to handle the crash more gracefully
    // and allow your app to continue executing, you should 1) destroy the
    // current WebView instance, 2) specify logic for how the app can
    // continue executing, and 3) return "true" instead.
    return false
}
}
}
*/